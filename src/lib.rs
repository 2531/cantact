use rusb::Error as LibUsbError;
use std::sync::mpsc::{channel, Sender, TryRecvError};
use std::sync::{Arc, Mutex};
/// Public API for interacting with CANtact devices.
use std::thread;
mod device;
use device::*;

/// Implementation of C bindings
pub mod c;
/// Implementation of Python bindings
#[cfg(python)]
pub mod python;

/// Errors generated by this library
#[derive(Debug)]
pub enum Error {
    /// During setup, the device could not be found on the system.
    DeviceNotFound,
    /// Timeout while communicating with the device.
    Timeout,
    /// Attempted to perform an action on a device that is running when this is not allowed.
    Running,
    /// Attempted to perform an action on a device that is not running when this is not allowed.
    NotRunning,
    /// Errors from libusb
    UsbError(LibUsbError),
    /// Attempt to poll while callback is enabled
    CallbacksEnabled,
}

/// Definition of a CAN frame
#[derive(Debug, Clone)]
pub struct Frame {
    /// CAN frame arbitration ID
    pub can_id: u32,
    /// CAN frame Data Length Code (DLC)
    pub can_dlc: u8,
    /// Device channel used to send or receive the frame
    pub channel: u8,
    /// Frame data contents
    pub data: [u8; 8],
}

/// Public CANtact interface for interacting with devices
pub struct Interface {
    dev_mutex_main: Arc<Mutex<Device>>,
    dev_mutex_thread: Arc<Mutex<Device>>,

    // channel for transmitting can frames to thread for tx
    // when None, thread is not running
    // when this Sender is dropped, the thread is stopped
    can_tx: Option<Sender<Frame>>,

    // when true, frames sent by this device are received by the driver
    loopback: bool,
}

// echo id for non-loopback frames
const RX_ECHO_ID: u32 = 4294967295;

impl Interface {
    pub fn new() -> Result<Interface, Error> {
        let dev = match Device::new() {
            Some(d) => d,
            None => return Err(Error::DeviceNotFound),
        };

        let dev_mutex = Arc::new(Mutex::new(dev));

        let i = Interface {
            dev_mutex_thread: Arc::clone(&dev_mutex),
            dev_mutex_main: dev_mutex,
            can_tx: None,
            loopback: false,
        };

        // TODO get btconsts
        Ok(i)
    }

    /// Starts CAN communication for the device.
    /// The rx_callback closure provided will be called on every frame received.
    pub fn start(
        &mut self,
        mut rx_callback: impl FnMut(Frame) + Sync + Send + 'static,
    ) -> Result<(), Error> {
        let mode = Mode {
            mode: CanMode::Start as u32,
            flags: 0,
        };

        // set up the thread
        let (can_tx_tx, can_tx_rx) = channel();
        self.can_tx = Some(can_tx_tx);

        let dev_mutex_thread = self.dev_mutex_thread.clone();
        let loopback = self.loopback.clone();

        thread::spawn(move || {
            let dev = dev_mutex_thread.lock().unwrap();
            let can_tx = can_tx_rx;
            loop {
                // try to read a frame
                match dev.get_frame() {
                    Ok(hf) => {
                        if hf.echo_id != RX_ECHO_ID && !loopback {
                            // frame is an echoed frame, do not treat as received
                            // unless we're in loopback mode
                            continue;
                        }
                        let f = Frame {
                            can_id: hf.can_id,
                            can_dlc: hf.can_dlc,
                            data: hf.data,
                            channel: hf.channel,
                        };
                        rx_callback(f)
                    }
                    Err(LibUsbError::Timeout) => {}
                    Err(_) => { /* TODO */ }
                }

                // try to send a frame
                match can_tx.try_recv() {
                    Err(TryRecvError::Empty) => { /* no frames to send */ }
                    Err(TryRecvError::Disconnected) => {
                        // channel disconnected, kill thread
                        return;
                    }
                    Ok(f) => {
                        let hf = HostFrame {
                            echo_id: 1,
                            flags: 0,
                            reserved: 0,
                            can_id: f.can_id,
                            can_dlc: f.can_dlc,
                            channel: f.channel,
                            data: f.data,
                        };
                        dev.send_frame(hf).unwrap();
                    }
                }
            }
        });

        // tell the device to go on bus
        let dev = self.dev_mutex_main.lock().unwrap();
        // TODO multi-channel
        dev.set_mode(0, mode).unwrap();
        Ok(())
    }

    /// Stops device CAN communication
    pub fn stop(&mut self) -> Result<(), Error> {
        let can_tx = match &self.can_tx {
            Some(v) => v,
            None => return Err(Error::NotRunning),
        };

        // drop the channel to stop the thread
        drop(can_tx);
        // mark thread as not running
        self.can_tx = None;

        let dev = self.dev_mutex_main.lock().unwrap();

        let mode = Mode {
            mode: CanMode::Reset as u32,
            flags: 0,
        };

        // TODO multi-channel
        dev.set_mode(0, mode).unwrap();

        Ok(())
    }

    /// Sets bitrate for specified channel to requested bitrate value in bits per second
    pub fn set_bitrate(&self, channel: u16, bitrate: u32) -> Result<(), Error> {
        match &self.can_tx {
            None => {}
            Some(_) => return Err(Error::Running),
        };

        let dev = self.dev_mutex_main.lock().unwrap();

        // TODO get device clock
        let bt = calculate_bit_timing(48000000, bitrate);
        dev.set_bit_timing(channel, bt)
            .expect("failed to set bit timing");

        Ok(())
    }

    /// Sends a single CAN frame using the device
    pub fn send(&self, f: Frame) -> Result<(), Error> {
        match &self.can_tx {
            Some(tx) => tx.send(f).unwrap(),
            None => return Err(Error::NotRunning),
        };
        Ok(())
    }
}

fn calculate_bit_timing(device_clk: u32, bitrate: u32) -> BitTiming {
    // use a fixed divider and sampling point
    let brp = 6;
    let sample_point = 0.68;

    let can_clk = device_clk / brp;
    // number of time quanta in segement 1 and segment 2
    // subtract 1 for the fixed sync segment
    let tqs = (can_clk / bitrate) - 1;
    // split tqs into two segments
    let seg1 = (tqs as f32 * sample_point).round() as u32;
    let seg2 = (tqs as f32 * (1.0 - sample_point)).round() as u32;
    println!(
        "bitrate = {}, can_clk = {}, tqs = {}, seg1 = {}, seg2 = {}",
        bitrate, can_clk, tqs, seg1, seg2
    );

    /*
    BitTiming{
        prop_seg: 0,
        phase_seg1: 13,
        phase_seg2: 2,
        sjw: 1,
        brp: 6,
    }
    */
    BitTiming {
        prop_seg: 0,
        phase_seg1: seg1,
        phase_seg2: seg2,
        sjw: 1,
        brp: brp,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_bit_timing() {
        let dev_clock = 48000000;
        let bt_1000000 = calculate_bit_timing(dev_clock, 1000000);
        assert_eq!(
            bt_1000000.prop_seg + bt_1000000.phase_seg1 + bt_1000000.phase_seg2 + 1,
            8
        );
        let bt_500000 = calculate_bit_timing(dev_clock, 500000);
        assert_eq!(
            bt_500000.prop_seg + bt_500000.phase_seg1 + bt_500000.phase_seg2 + 1,
            16
        );
        let bt_250000 = calculate_bit_timing(dev_clock, 250000);
        assert_eq!(
            bt_250000.prop_seg + bt_250000.phase_seg1 + bt_250000.phase_seg2 + 1,
            32
        );
        let bt_125000 = calculate_bit_timing(dev_clock, 125000);
        assert_eq!(
            bt_125000.prop_seg + bt_125000.phase_seg1 + bt_125000.phase_seg2 + 1,
            64
        );
        let bt_33000 = calculate_bit_timing(dev_clock, 33000);
    }
}
