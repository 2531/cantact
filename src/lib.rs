use rusb::Error as LibUsbError;
use std::sync::mpsc::{channel, RecvTimeoutError, Sender};
use std::sync::{Arc, Mutex};
/// Public API for interacting with CANtact devices.
use std::thread;
use std::time;
mod device;
use device::*;

/// Implementation of C bindings
pub mod c;
/// Implementation of Python bindings
#[cfg(python)]
pub mod python;

/// Errors generated by this library
#[derive(Debug)]
pub enum Error {
    /// During setup, the device could not be found on the system.
    DeviceNotFound,
    /// Timeout while communicating with the device.
    Timeout,
    /// Attempted to perform an action on a device that is running when this is not allowed.
    Running,
    /// Attempted to perform an action on a device that is not running when this is not allowed.
    NotRunning,
    /// Errors from libusb
    UsbError(LibUsbError),
    /// Attempt to poll while callback is enabled
    CallbacksEnabled,
}

/// Definition of a CAN frame
#[derive(Debug, Clone)]
pub struct Frame {
    /// CAN frame arbitration ID
    pub can_id: u32,
    /// CAN frame Data Length Code (DLC)
    pub can_dlc: u8,
    /// Device channel used to send or receive the frame
    pub channel: u8,
    /// Frame data contents
    pub data: [u8; 8],
}

/// Public CANtact interface for interacting with devices
pub struct Interface {
    // when None, device thread is not running
    // write true to stop device thread
    stop: Option<Sender<bool>>,

    dev_mutex_main: Arc<Mutex<Device>>,
    dev_mutex_thread: Arc<Mutex<Device>>,

    // when true, frames sent by this device are received by the driver
    loopback: bool,
}

// echo id for non-loopback frames
const RX_ECHO_ID: u32 = 4294967295;

impl Interface {
    pub fn new() -> Result<Interface, Error> {
        let dev = match Device::new() {
            Some(d) => d,
            None => return Err(Error::DeviceNotFound),
        };

        let dev_mutex = Arc::new(Mutex::new(dev));

        let i = Interface {
            dev_mutex_thread: Arc::clone(&dev_mutex),
            dev_mutex_main: dev_mutex,
            stop: None,
            loopback: false,
        };

        // TODO get btconsts
        Ok(i)
    }

    /// Starts CAN communication for the device.
    /// The rx_callback closure provided will be called on every frame received.
    pub fn start(
        &mut self,
        mut rx_callback: impl FnMut(Frame) + Sync + Send + 'static,
    ) -> Result<(), Error> {
        let mode = Mode {
            mode: CanMode::Start as u32,
            flags: 0,
        };

        // set up the rx thread
        let (stop_tx, stop_rx) = channel();
        self.stop = Some(stop_tx);

        let dev_mutex_thread = self.dev_mutex_thread.clone();
        let loopback = self.loopback.clone();

        thread::spawn(move || {
            loop {
                {
                    let dev = dev_mutex_thread.lock().unwrap();
                    match dev.get_frame() {
                        Ok(hf) => {
                            if hf.echo_id != RX_ECHO_ID && !loopback {
                                // frame is an echoed frame, do not treat as received
                                // unless we're in loopback mode
                                continue;
                            }
                            let f = Frame {
                                can_id: hf.can_id,
                                can_dlc: hf.can_dlc,
                                data: hf.data,
                                channel: hf.channel,
                            };

                            rx_callback(f)
                        }
                        Err(_) => {} // TODO handle this
                    }
                }

                // kill thread when requested
                match stop_rx.recv_timeout(time::Duration::from_micros(10)) {
                    Err(RecvTimeoutError::Timeout) => {}
                    Ok(b) => {
                        if b {
                            return;
                        }
                    }
                    Err(e) => panic!(e),
                };
            }
        });

        // tell the device to go on bus
        let dev = self.dev_mutex_main.lock().unwrap();
        // TODO multi-channel
        dev.set_mode(0, mode).unwrap();
        Ok(())
    }

    /// Stops device CAN communication
    pub fn stop(&mut self) -> Result<(), Error> {
        let s = match &self.stop {
            Some(v) => v,
            None => return Err(Error::NotRunning),
        };

        let dev = self.dev_mutex_main.lock().unwrap();

        let mode = Mode {
            mode: CanMode::Reset as u32,
            flags: 0,
        };

        // TODO multi-channel
        dev.set_mode(0, mode).unwrap();

        // stop the thread and mark it as not running
        s.send(true).expect("failed to stop thread");
        self.stop = None;

        Ok(())
    }

    /// Sets bitrate for specified channel to requested bitrate value in bits per second
    pub fn set_bitrate(&self, channel: u16, bitrate: u32) -> Result<(), Error> {
        match &self.stop {
            None => {}
            Some(_) => return Err(Error::Running),
        };

        let dev = self.dev_mutex_main.lock().unwrap();

        // TODO get device clock
        let bt = calculate_bit_timing(48000000, bitrate);
        dev.set_bit_timing(channel, bt)
            .expect("failed to set bit timing");

        Ok(())
    }

    /// Sends a single CAN frame using the device
    pub fn send(&self, f: Frame) -> Result<(), Error> {
        let dev = self.dev_mutex_main.lock().unwrap();

        let hf = HostFrame {
            echo_id: 1,
            can_id: f.can_id,
            can_dlc: f.can_dlc,
            channel: f.channel,
            flags: 0,
            reserved: 0,
            data: f.data,
        };

        dev.send_frame(hf).unwrap(); // TODO error handling
        Ok(())
    }
}

fn calculate_bit_timing(device_clk: u32, bitrate: u32) -> BitTiming {
    // use a fixed divider and sampling point
    let brp = 6;
    let sample_point = 0.68;

    let can_clk = device_clk / brp;
    // number of time quanta in segement 1 and segment 2
    // subtract 1 for the fixed sync segment
    let tqs = (can_clk / bitrate) - 1;
    // split tqs into two segments
    let seg1 = (tqs as f32 * sample_point).round() as u32;
    let seg2 = (tqs as f32 * (1.0 - sample_point)).round() as u32;
    println!(
        "bitrate = {}, can_clk = {}, tqs = {}, seg1 = {}, seg2 = {}",
        bitrate, can_clk, tqs, seg1, seg2
    );

    /*
    BitTiming{
        prop_seg: 0,
        phase_seg1: 13,
        phase_seg2: 2,
        sjw: 1,
        brp: 6,
    }
    */
    BitTiming {
        prop_seg: 0,
        phase_seg1: seg1,
        phase_seg2: seg2,
        sjw: 1,
        brp: brp,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_bit_timing() {
        let dev_clock = 48000000;
        let bt_1000000 = calculate_bit_timing(dev_clock, 1000000);
        assert_eq!(
            bt_1000000.prop_seg + bt_1000000.phase_seg1 + bt_1000000.phase_seg2 + 1,
            8
        );
        let bt_500000 = calculate_bit_timing(dev_clock, 500000);
        assert_eq!(
            bt_500000.prop_seg + bt_500000.phase_seg1 + bt_500000.phase_seg2 + 1,
            16
        );
        let bt_250000 = calculate_bit_timing(dev_clock, 250000);
        assert_eq!(
            bt_250000.prop_seg + bt_250000.phase_seg1 + bt_250000.phase_seg2 + 1,
            32
        );
        let bt_125000 = calculate_bit_timing(dev_clock, 125000);
        assert_eq!(
            bt_125000.prop_seg + bt_125000.phase_seg1 + bt_125000.phase_seg2 + 1,
            64
        );
        let bt_33000 = calculate_bit_timing(dev_clock, 33000);
    }
}
